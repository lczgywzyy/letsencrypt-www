#!/bin/bash
set -e
set -u
set -o pipefail
exec 3>&-

BASE_DIR=$(dirname $0)
SCRIPT_PATH="$( cd "${BASE_DIR}" && pwd -P )"
CERT_DIR="./cert"

export LETS_ENCRYPT_WWW_LIB_PATH="${SCRIPT_PATH}/lib"
export CERT_DIR="${CERTDIR}"

source "${LETS_ENCRYPT_WWW_LIB_PATH}/json.sh"
source "${LETS_ENCRYPT_WWW_LIB_PATH}/formatter.sh"
source "${LETS_ENCRYPT_WWW_LIB_PATH}/ssl.sh"
source "${LETS_ENCRYPT_WWW_LIB_PATH}/http.sh"
source "${LETS_ENCRYPT_WWW_LIB_PATH}/utils.sh"

FQDN=

export DNSPod_HOOK="./provider/dnspod.sh"
DNSPod_RECORD_ID=

deploy_challenge() {
  local identifier="$(echo "${1}" | get_json_string_value identifier)"
  local keyAuth="$(echo "${1}" | get_json_string_value keyAuth)"
  DNSPod_RECORD_ID="$("${DNSPod_HOOK}" "create_txt_record" ${identifier} ${keyAuth})"
}

clean_challenge() {
  local identifier="$(echo "${1}" | get_json_string_value identifier)"
  "${DNSPod_HOOK}" "rm_txt_record" ${identifier} ${DNSPod_RECORD_ID}
}

check_challenge_status() {
  local identifier="$(echo "${1}" | get_json_string_value identifier)"

  local deployStatus=False
  while [[ "${deployStatus}" = False ]]; do
    sleep 5
    deployStatus="$("${DNSPod_HOOK}" "find_txt_record" ${identifier})"
  done
}

valid_challenge() {
  local accountRSA="${1}"
  local challengeArgs="${2}"

  local keyAuth="$(echo "${challengeArgs}" | get_json_string_value keyAuth)"
  local url="$(echo "${challengeArgs}" | get_json_string_value url)"

  local payload='{"keyAuthorization": "'"${keyAuth}"'"}'
  local payload64=$(printf '%s' "${payload}" | _urlbase64)
  local protected64="$(printf '%s' "$(_get_jwt "${url}")" | _urlbase64)"

  result="$(_post_signed_request "${url}" "${accountRSA}" "${protected64}" "${payload64}" | clean_json)"
  reqSta="$(printf '%s\n' "${result}" | get_json_string_value status)"

  while [[ "${reqSta}" = "pending" ]]; do
      sleep 1
      result="$(http_get "${url}")"
      reqSta="$(printf '%s\n' "${result}" | get_json_string_value status)"
  done

  if [[ "${reqSta}" = "valid" ]]; then
      echo " + Challenge is valid!"
  else
      echo " - Challenge failed!"
  fi
}

generate_csr() {
  local priKey="${1}" csr="${2}"
  local subj="$(ssl_generate_subject_with_domain ${FQDN})"
  local san="$(ssl_generate_san_with_domain ${FQDN})"

  local tmpSSLCnf="$(mk_tmp_file)" #TODO REMOVE
  cat "$(ssl_get_conf)" > "${tmpSSLCnf}"
  echo "${san}" >> "${tmpSSLCnf}"

  openssl req -new -sha256 -key "${priKey}" -out "${csr}" -subj "${subj}" -reqexts SAN -config "${tmpSSLCnf}"
}

_check_fd_3() {
  if { true >&3; } 2>/dev/null; then
      : # fd 3 looks OK
  else
      exit_err "_check_fd_3: FD 3 not open"
  fi
}

sign_csr() {
  _check_fd_3

  local accountRSA="${1}" csr="${2}"
  local finalize="$(echo "${_CA_ORDER}" | get_json_string_value finalize)"

  local csr64="$( <<<"${csr}" openssl req -config "$(ssl_get_conf)" -outform DER | _urlbase64)"
  local payload='{"csr": "'"${csr64}"'"}'
  local payload64=$(printf '%s' "${payload}" | _urlbase64)
  local protected64="$(printf '%s' "$(_get_jwt "${finalize}")" | _urlbase64)"

  local result="$(_post_signed_request "${finalize}" "${accountRSA}" "${protected64}" "${payload64}" | clean_json)"
  local certUrl="$(echo "${result}" | get_json_string_value certificate)"
  local crt="$(http_get "${certUrl}")"

  echo " + Checking certificate..."
#  ssl_print_in_text_form <<<"${crt}"

  echo "${crt}" >&3
  echo " + Done!"
}

produce_cert() {
  local timestamp="${1}"
  local tmpCert="$(mk_tmp_file)"
  local tmpChain="$(mk_tmp_file)"

  awk '{print >out}; /----END CERTIFICATE-----/{out=tmpChain}' out="${tmpCert}" tmpChain="${tmpChain}" "${CERTDIR}/cert-${timestamp}.pem"

  mv "${CERTDIR}/cert-${timestamp}.pem" "${CERTDIR}/fullchain-${timestamp}.pem"

  cat "${tmpCert}" > "${CERTDIR}/cert-${timestamp}.pem"
  cat "${tmpChain}" > "${CERTDIR}/chain-${timestamp}.pem"

  rm "${tmpCert}" "${tmpChain}"
}

main() {
  exit 0

  check_command

  case "$(get_command)" in
    issue) command_issue;;
    version) command_version;;
    *) command_help; exit 1;;
  esac


  FQDN="${1}"

  local timestamp="$(date +%s)"

  check_msg "Init environment..."
  init_ca_config

  check_msg "Apply Let's Encrypt account..."
  local accountRSA="${CERTDIR}/account-key-${timestamp}.pem"
  ssl_generate_rsa_2048 "${accountRSA}"
  reg_account "${accountRSA}"

  check_msg "Start new order..."
  new_order "${accountRSA}"

  check_msg "Deploy dns-01 challenge to provider DNSPod..."
  local challengeArgs="$(build_authz "${accountRSA}")"

  deploy_challenge "${challengeArgs}"
  check_challenge_status "${challengeArgs}"
  valid_challenge "${accountRSA}" "${challengeArgs}"
  clean_challenge "${challengeArgs}"

  check_msg "Deploy dns-01 challenge to provider DNSPod..."
  local privateKey="${CERTDIR}/private-${timestamp}.pem"
  local csr="${CERTDIR}/${timestamp}.csr"
  local crt="${CERTDIR}/cert-${timestamp}.pem"

  ssl_generate_rsa_2048 "${privateKey}"
  generate_csr "${privateKey}" "${csr}"
  sign_csr "${accountRSA}" "$(< "${csr}")" 3>"${crt}"

  check_msg "Produce cert..."
  produce_cert "${timestamp}"

  check_msg "Done, www domain "${FQDN}" cert at: "
  echo "================"
  echo "$( cd "${BASE_DIR}/${CERTDIR}" && pwd -P )"
  echo "================"

}

main "${@-}"